### **Введение в Асинхронное Программирование в Python**

**Цель урока:** Понять, зачем нужно асинхронное программирование, и научиться писать простые асинхронные программы с помощью `async/await`.

**Длительность:** 60-90 минут.

---

#### **1. Введение (5 минут)**

**Объяснение для новичка:**
Представьте, что вы официант в ресторане.

*   **Синхронный подход (обычный):** Вы принимаете заказ от столика №1, идете на кухню и ждете, пока повар приготовит блюдо. Стоите и ждете. Только когда блюдо готово, вы несете его столику №1 и только потом идете к столику №2. Время тратится впустую на ожидание.
*   **Асинхронный подход:** Вы принимаете заказ от столика №1 и передаете его на кухню. Но вместо ожидания вы сразу идете к столику №2, принимаете их заказ. Потом к столику №3. Когда на кухне блюдо для №1 готово, вас вызывают, и вы относите его. Вы не простаиваете, а выполняете полезную работу пока что-то готовится.

**Вывод:** Асинхронность позволяет одной программе (одному потоку) выполнять несколько задач одновременно, эффективно используя время простоя, которое обычно уходит на ожидание (ответа от сети, чтения файла, etc.).

---

#### **2. Ключевые понятия (10 минут)**

Объясняем три кита асинхронности:

1.  **`async`** (асинхронная функция):
    *   Ключевое слово для объявления функции, которая будет работать асинхронно.
    *   Такая функция вызывается, но не выполняется сразу. Она возвращает **корутину** (coroutine), которую нужно запустить.
    *   Пример: `async def my_function():`

2.  **`await`** (ожидание):
    *   Ключевое слово, которое ставится перед вызовом другой `async`-функции или операции, требующей времени (например, запрос в сеть).
    *   Оно говорит: "Я, корутина, сейчас буду ждать результата этой операции. Но пока я жду, **событийный цикл** может выполнять другие корутины, а не блокировать весь поток".
    *   `await` можно использовать только внутри `async`-функций.

3.  **Событийный цикл (Event Loop):**
    *   Это "мозг" асинхронной программы. Диспетчер, который управляет выполнением всех корутин.
    *   Он следит, какие корутины готовы к работе, а какие ожидают (`await`). Он запускает готовые и приостанавливает те, что ждут.
    *   Мы не создаем его вручную, а используем `asyncio.run()`.

---

#### **3. Пишем первый асинхронный код (15 минут)**

**Задача:** Написать программу, которая имитирует два долгих задания (например, загрузку файлов), но делает это асинхронно.

```python
# Импортируем нужную библиотеку
import asyncio

# Объявляем наши асинхронные функции
async def download_file(file_name, seconds):
    print(f"Начинаем загрузку {file_name}")
    # await говорит: "Я буду ждать, но цикл событий может делать другое!"
    await asyncio.sleep(seconds)  # Имитируем долгую операцию (например, сетевой запрос)
    print(f"Загрузка {file_name} завершена!")

# Главная асинхронная функция
async def main():
    # Создаем две корутины. Они НЕ выполняются сразу, а просто планируются.
    task1 = download_file("file1.txt", 3)
    task2 = download_file("file2.txt", 2)

    # Запускаем корутины и ждем их завершения
    print("Запускаем корутины одновременно и ждем...")
    await asyncio.gather(task1, task2)
    # gather - собирает несколько корутин и ожидает завершения всех.

# Запускаем всю нашу асинхронную программу.
# asyncio.run() создает событийный цикл, запускает main() и закрывает цикл.
asyncio.run(main())
```

**Запустите код и обсудите вывод:**
```
Запускаем корутины одновременно и ждем...
Начинаем загрузку file1.txt
Начинаем загрузку file2.txt
(здесь программа НЕ ждет 3 секунды, а сразу выводит оба сообщения)
Загрузка file2.txt завершена!  # Ждала всего 2 сек, потому и завершилась первой
Загрузка file1.txt завершена!
```

**Ключевое наблюдение:** Время выполнения программы ~3 секунды, а не ~5 (3+2), потому что задачи выполнялись *конкурентно*.

---

#### **4. Сравнение: Синхронный vs Асинхронный (10 минут)**

Перепишем тот же пример в синхронном стиле:

```python
import time

def download_file_sync(file_name, seconds):
    print(f"Начинаем загрузку {file_name}")
    time.sleep(seconds)  # Блокирующая функция! Весь поток засыпает.
    print(f"Загрузка {file_name} завершена!")

def main_sync():
    start = time.time()
    download_file_sync("file1.txt", 3)
    download_file_sync("file2.txt", 2)
    end = time.time()
    print(f"Общее время выполнения: {end - start:.2f} секунд")

main_sync()
```

**Вывод:**
```
Начинаем загрузку file1.txt
Загрузка file1.txt завершена!
Начинаем загрузку file2.txt
Загрузка file2.txt завершена!
Общее время выполнения: 5.00 секунд
```

**Обсуждение:** В синхронной версии вторая задача ждет, пока полностью выполнится первая. Весь код блокируется на время `time.sleep()`. Асинхронная версия эффективнее.

---

#### **5. Практическое задание (15 минут)**

**Задача:** У нас есть три веб-запроса (их имитируют `asyncio.sleep`). Нужно "отправить" их одновременно и обработать результаты по мере их "поступления".

```python
import asyncio

async def fetch_data(task_name, delay):
    print(f"[{task_name}] Запрос отправлен. Ожидаем {delay} сек.")
    await asyncio.sleep(delay)
    print(f"[{task_name}] Данные получены!")
    return f"Данные от {task_name}"

async def main():
    # Задание: Используйте asyncio.gather, чтобы запустить все три задачи конкурентно.
    # Соберите результаты в переменную `results`.
    results = await asyncio.gather(
        fetch_data("Запрос к API", 3),
        fetch_data("Запрос к БД", 1),
        fetch_data("Пинг сервера", 2),
    )

    # После завершения всех задач выведите результаты.
    print("\nВсе задачи завершены! Результаты:")
    for result in results:
        print(result)

asyncio.run(main())
```

**Вопросы для проверки понимания:**
1.  В каком порядке выводятся сообщения о получении данных? (По готовности: БД, Пинг, API)
2.  Почему общее время выполнения программы ~3 секунды, а не ~6?
3.  Что содержит переменная `results`? (Список с результатами возвращенными из корутин, в порядке их передачи в `gather`, а не выполнения!).

---

#### **6. Важные моменты и подведение итогов (5 минут)**

*   **Что запомнить:**
    *   `async def` — объявляет асинхронную функцию.
    *   `await` — ставится перед "долгой" операцией внутри `async`-функций.
    *   `asyncio.run()` — точка входа для запуска асинхронной программы.
    *   `asyncio.gather()` — полезный инструмент для запуска нескольких корутин.

*   **Где использовать:**
    *   Веб-серверы, которые ждут ответов от клиентов или БД.
    *   Скачивание нескольких файлов из интернета.
    *   Работа с сетевыми подключениями (чаты, боты).

*   **Чего нельзя делать:**
    *   Использовать внутри асинхронных функций обычные блокирующие операции (например, `time.sleep(5)` вместо `await asyncio.sleep(5)`). Это "сломает" всю магию.

**Домашнее задание:** Напишите программу, которая "отправляет" 5 писем (каждое занимает случайное время от 1 до 3 секунд) асинхронно. Измерьте общее время выполнения и сравните, сколько бы оно заняло в синхронном варианте.

Удачи в изучении! Это сложная, но очень важная и интересная тема.